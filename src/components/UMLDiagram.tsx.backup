import React, { useCallback, useEffect, useState } from "react";
import { Paper, useGraph } from "@joint/react";
import { UMLClass } from "./UMLClass";
import type { CustomElement, UMLRelationship } from "../types";
import {
  classTemplates,
  validateElementPosition,
} from "../constants/templates";

// Componente que maneja el drop y recibe el paper como prop
const DropZone: React.FC<{
  paper: any;
  onAddElement: (
    template: keyof typeof classTemplates,
    x?: number,
    y?: number,
    containerWidth?: number,
    containerHeight?: number
  ) => void;
}> = ({ paper, onAddElement }) => {
  const handleDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault();
      const template = e.dataTransfer.getData(
        "text/plain"
      ) as keyof typeof classTemplates;

      console.log("Drop event on diagram:", template, classTemplates[template]);

      if (template && paper) {
        // Usar clientToLocalPoint para conversión correcta de coordenadas
        const localPoint = paper.clientToLocalPoint({
          x: e.clientX,
          y: e.clientY,
        });

        console.log("Coordenadas convertidas:", localPoint.x, localPoint.y);

        // Obtener dimensiones del contenedor para validación
        const rect = e.currentTarget.getBoundingClientRect();
        const containerWidth = rect.width;
        const containerHeight = rect.height;

        console.log(
          "Llamando onAddElement con coordenadas:",
          localPoint.x,
          localPoint.y
        );
        onAddElement(
          template,
          localPoint.x,
          localPoint.y,
          containerWidth,
          containerHeight
        );
      } else {
        console.log(
          "No se puede procesar drop: template =",
          template,
          "paper disponible =",
          !!paper
        );
      }
    },
    [onAddElement, paper]
  );

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "copy";
  }, []);

  return (
    <div
      style={{
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        zIndex: 10,
      }}
      onDrop={handleDrop}
      onDragOver={handleDragOver}
    >
      {/* Área invisible para capturar drops */}
    </div>
  );
};

// Componente que maneja el drop y recibe el paper como prop
const DropZone: React.FC<{
  paper: any;
  onAddElement: (
    template: keyof typeof classTemplates,
    x?: number,
    y?: number,
    containerWidth?: number,
    containerHeight?: number
  ) => void;
}> = ({ paper, onAddElement }) => {

interface UMLDiagramProps {
  onAddElement: (
    template: keyof typeof classTemplates,
    x?: number,
    y?: number,
    containerWidth?: number,
    containerHeight?: number
  ) => void;
  selectedElement: CustomElement | UMLRelationship | null;
  onSelectElement: (element: CustomElement) => void;
  onUpdateElementPosition: (elementId: string, x: number, y: number) => void;
  onSelectRelationship: (relationship: UMLRelationship) => void;
  dynamicLinks: UMLRelationship[];
  elementMap: Map<string, CustomElement>;
}

export const UMLDiagram: React.FC<UMLDiagramProps> = ({
  onAddElement,
  selectedElement,
  onSelectElement,
  onUpdateElementPosition,
  onSelectRelationship,
  dynamicLinks,
  elementMap,
}) => {
  // Hook para acceder al grafo de JointJS
  const graph = useGraph();
  const [paper, setPaper] = useState<any>(null);

  // Función para renderizar elementos (requerida por Paper)
  const renderElement = useCallback(() => null, []);

  // Buscar el paper después de que se monte
  useEffect(() => {
    const findPaper = () => {
      // Intentar acceder al paper a través del DOM
      const paperElement = document.querySelector('.joint-paper');
      if (paperElement) {
        console.log("Elemento joint-paper encontrado");

        // En algunos casos, el paper está disponible como propiedad del elemento
        if ((paperElement as any).paper) {
          console.log("Paper encontrado via elemento.paper");
          setPaper((paperElement as any).paper);
          return true;
        }

        // Buscar en propiedades del elemento
        const paperProps = ['paper', '_paper', '__paper'];
        for (const prop of paperProps) {
          if ((paperElement as any)[prop]) {
            console.log(`Paper encontrado via elemento.${prop}`);
            setPaper((paperElement as any)[prop]);
            return true;
          }
        }
      }

      // Intentar acceder a través del graph
      if (graph) {
        const graphPaper = (graph as any).get?.('paper') || (graph as any)._paper;
        if (graphPaper) {
          console.log("Paper encontrado via graph");
          setPaper(graphPaper);
          return true;
        }
      }

      return false;
    };

    // Intentar encontrar inmediatamente
    if (!findPaper()) {
      // Si no se encontró, intentar múltiples veces
      let attempts = 0;
      const maxAttempts = 10;

      const interval = setInterval(() => {
        attempts++;
        console.log(`Intento ${attempts}/${maxAttempts} de encontrar paper`);

        if (findPaper() || attempts >= maxAttempts) {
          clearInterval(interval);
          if (attempts >= maxAttempts) {
            console.error("No se pudo encontrar el paper después de", maxAttempts, "intentos");
          }
        }
      }, 200);

      return () => clearInterval(interval);
    }
  }, [graph]);

  // Escuchar cambios de posición de elementos
  useEffect(() => {
    if (!graph) return;

    const handleElementMove = (element: {
      id: string;
      position: () => { x: number; y: number };
      set: (key: string, value: { x: number; y: number }) => void;
    }) => {
      const position = element.position();
      let { x, y } = position;
      const elementId = element.id;

      // Los elementos JointJS están en la misma posición exacta que los elementos React
      // No se necesita conversión de coordenadas

      // Validar límites para evitar que los elementos se salgan del área visible
      // Obtener dimensiones del contenedor del diagrama
      const diagramElement = document.querySelector(
        "[data-diagram]"
      ) as HTMLElement;
      if (diagramElement) {
        const containerWidth = diagramElement.offsetWidth;
        const containerHeight = diagramElement.offsetHeight;

        const validatedPosition = validateElementPosition(
          x,
          y,
          containerWidth,
          containerHeight
        );

        // Si la posición cambió, actualizarla en el grafo (sin conversión ya que coinciden exactamente)
        if (validatedPosition.x !== x || validatedPosition.y !== y) {
          element.set("position", validatedPosition);
          x = validatedPosition.x;
          y = validatedPosition.y;
        }
      }

      // Actualizar la posición en el estado de la aplicación
      onUpdateElementPosition(elementId, x, y);
    };

    // Escuchar el evento 'change:position' en todos los elementos
    graph.on("change:position", handleElementMove);

    // Cleanup
    return () => {
      graph.off("change:position", handleElementMove);
    };
  }, [graph, onUpdateElementPosition]);

  // Agregar event listeners directamente a los elementos DOM de los links
  useEffect(() => {
    const handleLinkElementClick = (event: Event) => {
      const target = event.target as HTMLElement;
      console.log("Link element clicked:", target);

      // Buscar el elemento padre que tenga el model-id
      const linkElement = target.closest("[model-id]") as HTMLElement;
      if (linkElement) {
        const linkId = linkElement.getAttribute("model-id");
        console.log("Found link ID from DOM:", linkId);
        if (linkId) {
          const relationship = dynamicLinks.find(
            (rel: UMLRelationship) => rel.id === linkId
          );
          console.log("Found relationship:", relationship);
          if (relationship) {
            onSelectRelationship(relationship);
          }
        }
      }
    };

    // Función para agregar listeners a los links existentes
    const addListenersToLinks = () => {
      // Buscar todos los elementos de link en el DOM
      const linkElements = document.querySelectorAll("[model-id]");
      console.log("Found link elements in DOM:", linkElements.length);

      linkElements.forEach((element) => {
        const modelId = element.getAttribute("model-id");
        // Verificar si es un link (no un elemento)
        const isLink = dynamicLinks.some((link) => link.id === modelId);
        if (isLink && !element.hasAttribute("data-link-listener")) {
          console.log("Adding click listener to link element:", modelId);
          element.addEventListener("click", handleLinkElementClick);
          element.setAttribute("data-link-listener", "true");
        }
      });
    };

    // Agregar listeners inicialmente
    setTimeout(addListenersToLinks, 100);

    // Observer para detectar cuando se agregan nuevos links al DOM
    const observer = new MutationObserver((mutations) => {
      let shouldAddListeners = false;
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node as Element;
              if (
                element.hasAttribute("model-id") ||
                element.querySelector("[model-id]")
              ) {
                shouldAddListeners = true;
              }
            }
          });
        }
      });
      if (shouldAddListeners) {
        setTimeout(addListenersToLinks, 50);
      }
    });

    // Observar cambios en el DOM
    const diagramElement = document.querySelector("[data-diagram]");
    if (diagramElement) {
      observer.observe(diagramElement, {
        childList: true,
        subtree: true,
      });
    }

    return () => {
      observer.disconnect();
      // Remover listeners de todos los elementos
      const linkElements = document.querySelectorAll("[data-link-listener]");
      linkElements.forEach((element) => {
        element.removeEventListener("click", handleLinkElementClick);
        element.removeAttribute("data-link-listener");
      });
    };
  }, [dynamicLinks, onSelectRelationship]);

  return (
    <div
      style={{
        height: "100%",
        border: "2px dashed #ccc",
        background: "#f9f9f9",
        position: "relative",
        borderRadius: "8px",
        overflow: "hidden",
      }}
      data-diagram
    >
      <div
        style={{
          position: "absolute",
          top: "10px",
          left: "10px",
          background: "rgba(255, 255, 255, 0.9)",
          padding: "5px 10px",
          borderRadius: "4px",
          fontSize: "12px",
          color: "#666",
          pointerEvents: "none",
          zIndex: 10,
        }}
      >
        {/* Arrastra elementos desde la barra lateral para agregarlos */}
      </div>
      <Paper
        width="100%"
        height="100%"
        renderElement={renderElement}
        useHTMLOverlay
        interactive
      />

      {/* DropZone para manejar drag & drop - renderizado fuera del Paper */}
      <DropZone paper={paper} onAddElement={onAddElement} />

      {/* Renderizar elementos UML absolutamente posicionados */}
      {Array.from(elementMap.entries()).map(([id, element]) => {
        console.log(
          "Renderizando elemento:",
          id,
          element.className,
          "en posición:",
          element.x,
          element.y
        );

        // Obtener la posición actual del elemento JointJS si existe
        let currentX = element.x;
        let currentY = element.y;

        if (graph) {
          const jointElement = graph.getCell(id);
          if (jointElement) {
            const jointPosition = jointElement.position();
            currentX = jointPosition.x;
            currentY = jointPosition.y;
            console.log("Posición actual del JointJS:", currentX, currentY);
          } else {
            console.log("No se encontró elemento JointJS para:", id);
          }
        }

        return (
          <div
            key={id}
            style={{
              position: "absolute",
              left: currentX,
              top: currentY,
              zIndex: 5,
              border: "2px solid red", // Debug border
            }}
          >
            <UMLClass
              element={element}
              isSelected={
                !!(
                  selectedElement &&
                  "className" in selectedElement &&
                  selectedElement?.id === element.id
                )
              }
              onSelect={onSelectElement}
            />
          </div>
        );
      })}
    </div>
  );
};
